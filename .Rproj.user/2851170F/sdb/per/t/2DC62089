{
    "contents" : "## Variance Swap Pricers\n## Author: Ming Tian\n## Copyright @2015 Ming Tian\n\n# Black-Scholes Pricer\nBSPricer <- function(S, K, r, Ttm, vol, type) {\n  d1 <- (1 / (vol * sqrt(Ttm))) * (log(S / K) + (r + vol^2/2) * Ttm)\n  d2 <- d1 - vol * sqrt(Ttm)\n  if (type == \"c\") {\n    # call price\n    CallPrice <- S * pnorm(d1) - K * exp(-r * Ttm) * pnorm(d2)\n    # return\n    return(CallPrice)\n  }\n  else if (type == \"p\") {\n    # put price\n    PutPrice <- pnorm(-d2) * K * exp(-r * Ttm) - pnorm(-d1) * S\n    # return\n    return(PutPrice)\n  }\n  else {\n    stop(\"Wrong input type!\")\n  }\n}\n\n# Black-Scholes Gamma\nBSGamma <- function(S, K, r, Ttm, vol) {\n  d1 <- (1 / (vol * sqrt(Ttm))) * (log(S / K) + (r + vol^2/2) * Ttm)\n  return(exp(0)*dnorm(d1)/(S*vol*sqrt(Ttm)))\n}\n\n# JPMorgan Model Pricer\nVarSwapPricer.SimpleVersion <- function(S, put_strikes, call_strikes, put_IVs, call_IVs, Ttm=1, r, Kvs) {\n  # check the inputs \n  if (length(put_strikes) != length(put_IVs)) {\n    stop(\"Put strikes are not as long as put IVs, please check!\")\n  }\n  if (length(call_strikes) != length(call_IVs)) {\n    stop(\"Call strikes are not as long as Call IVs, please check!\")\n  }\n  \n  # compute forward price firstly\n  fprice <- S * exp(r*Ttm)\n  \n  # calculate the price of puts\n  put_strikes_abs <- fprice * put_strikes\n  put_series <- apply(cbind(put_strikes_abs, put_IVs), 1, function(x) {\n    BSPricer(S = S, K = x[1], r = r, Ttm = Ttm, vol = x[2], type = \"p\")\n  })\n  put_series <- put_series / fprice\n  \n  # calculate the price of calls\n  call_strikes_abs <- fprice * call_strikes\n  call_series <- apply(cbind(call_strikes_abs, call_IVs), 1, function(x) {\n    BSPricer(S = S, K = x[1], r = r, Ttm = Ttm, vol = x[2], type = \"c\")\n  })\n  call_series <- call_series / fprice\n  \n  # sum the puts and calls\n  len1 <- length(put_strikes)\n  put_k0 <- put_strikes[1] - (put_strikes[2] - put_strikes[1])\n  put_weight <- (put_strikes[1:len1] - c(put_k0, put_strikes[1:(len1-1)])) / (put_strikes^2)\n  put_weight[put_strikes == 1] <- put_weight[put_strikes == 1] / 2\n  sum1 <- sum(put_series * put_weight)\n  len2 <- length(call_strikes)\n  call_k0 <- call_strikes[1] - (call_strikes[2] - call_strikes[1])\n  call_weight <- (call_strikes[1:len2] - c(call_k0, call_strikes[1:(len2-1)])) / (call_strikes^2)\n  call_weight[call_strikes == 1] <- call_weight[call_strikes == 1] / 2\n  sum2 <- sum(call_series * call_weight)\n  \n  # var swap price\n  varswap <- (2/Ttm) * (sum1 + sum2) - exp(-r*Ttm) * (Kvs^2)\n  \n  # return \n  return(varswap)\n}\n\n# # JPMorgan Model Pricer test\n# put_strikes_rate <- seq(from = 0.5, to = 1, by = 0.05)\n# call_strikes_rate <- seq(from = 1, to = 1.5, by = 0.05)\n# put_IVs_tmp <- c(0.276, 0.264, 0.252, 0.240, 0.227, 0.214, 0.200, 0.187, 0.173, 0.160, 0.148)\n# call_IVs_tmp <- c(0.148, 0.137, 0.129, 0.122, 0.119, 0.118, 0.119, 0.121, 0.125, 0.129, 0.134)\n# \n# # two input parameters\n# discount_factor <- 0.977368853\n# forward_price <- 2935.02\n# Kvs_tmp <- 0.16625\n# \n# rf=log(1/discount_factor)\n# S0 <- forward_price / exp(rf)\n# VarSwapPricer.SimpleVersion(S = S0, put_strikes = put_strikes_rate, call_strikes = call_strikes_rate, \n#                             put_IVs = put_IVs_tmp, call_IVs = call_IVs_tmp, r = rf, Kvs = Kvs_tmp) \n\n# Figure on page 13\n\n#assign the parameters firstly\nK = 110  #strike price\nmu = 0  #mean\nsig = 0.3  #sigma/annulaized volitility\nS0 = 100  #start stock price\nr = 0  #interest rate\nq = 0  #dividends of stock\ndt = 1/252  #time step\nT_m = 1  #maturity time\ntype = \"c\"  #option type\n\nPath <- function(S0_ = S0, mu_ = mu, dt_ = dt, T_m_ = T_m, seed_) {\n  # set random seed\n  set.seed(seed_)\n  # lognormal random number\n  sig1 <- 0.2\n  rand_vec1 <- rlnorm(n=200, meanlog = mu_ - 0.5*((sig1*sqrt(1/252))^2), sdlog = sig1*sqrt(1/252))\n  sig2 <- 0.3\n  rand_vec2 <- rlnorm(n=10, meanlog = mu_ - 0.5*((sig2*sqrt(1/252))^2), sdlog = sig2*sqrt(1/252))\n  sig3 <- 0.4\n  rand_vec3 <- rlnorm(n=41, meanlog = mu_ - 0.5*((sig3*sqrt(1/252))^2), sdlog = sig3*sqrt(1/252))\n  # return and price\n  rt_vec <- c(1, rand_vec1, rand_vec2, rand_vec3)\n  price_vec <- S0_ * cumprod(rt_vec)\n  # return\n  return(price_vec)\n}\n# path test\npath <- Path(seed_ = 5)\nplot(path, type=\"l\")\nabline(h=110, col=\"red\")\n\n#define a payoff function for vanilla options\nVanilla.Payoff <- function(K_ = K, S_end, type = \"c\")\n{\n  if(type == \"c\")  #Call\n  {\n    payoff <- max(0, (S_end - K_))\n  }\n  else  #Put\n  {\n    payoff <- max(0, (K_ - S_end))\n  }\n  payoff\n}\n\nDelta.Hedge.PnL <- function(PayoffFunc, path, K_ = K, S0_ = S0, sig_ = sig, sig_DH = sig, rf=r,\n                            mu_ = mu, dt_ = dt, T_m_ = T_m, type = \"c\") {\n  #decide the option type\n  if(type == \"c\")  #Call\n  {\n    # call option price\n    CallPrice <- BSPricer(S=S0_, K=K_, r=rf, Ttm=T_m_, vol=sig_, type=\"c\")\n    pnlfunc <- function(x) {\n      # calculate option P&L\n      S_end <- x[length(x)]\n      Opt_payoff <- PayoffFunc(K_ = K_, S_end, type = type)\n      \n      # calculate delta hedge P&L\n      S_path <- ts(x)\n      S_diff <- lag(S_path) - S_path\n      t_ts <- rev(seq(from=dt_, to=T_m_, by=dt_))\n      delta_vec <- pnorm( (1 / (sig_DH * sqrt(t_ts))) * (log(S_path / K_) + (0 + sig_DH^2/2) * t_ts) )\n      delta_vec <- delta_vec[-length(delta_vec)]\n      deltapayoff_vec <- delta_vec * S_diff\n      #deltapayoff <- sum(deltapayoff_vec)\n      \n      # return\n      cumsum(deltapayoff_vec) + CallPrice - Opt_payoff\n    }\n    pnl <- pnlfunc(path)\n  }\n  else  #Put\n  {\n    #do nothing for now\n  }\n  pnl\n}\n# test\npnl <- Delta.Hedge.PnL(PayoffFunc=Vanilla.Payoff, path=path)*100000\nplot(pnl, type=\"l\")\nabline(h=0, col=\"blue\")\n# realized vol\nrl_vol <- sd(diff(log(path), 1))*sqrt(252)\nrl_50dvol <- sapply(c(51:252), function(x) {\n  sd(diff(log(path[(x-50):x]), 1) * sqrt(252))\n})\n\n# gamma\ngamma <- path^2 * BSGamma(S=path, K=K, r=r, Ttm=rev(seq(from=1/252, to=1, by=1/252)), vol=sig)\nplot(gamma, type=\"l\")\n\n# graph (a)\nfiga_data <- cbind(path, rep(K, 252), c(1,pnl))\n\n\n\n# Goldman Sachs Model Pricer\nFairVariance <- function(S, put_strikes, call_strikes, put_IVs, call_IVs, Ttm=1, r, ref_S) {\n  # check the inputs \n  if (length(put_strikes) != length(put_IVs)) {\n    stop(\"Put strikes are not as long as put IVs, please check!\")\n  }\n  if (length(call_strikes) != length(call_IVs)) {\n    stop(\"Call strikes are not as long as Call IVs, please check!\")\n  }\n  \n  # compute weights firstly\n  f <- function(ST) (2/Ttm)*((ST - ref_S)/ref_S - log(ST/ref_S))\n  # for call weights\n  call_weights <- c()\n  call_weights[1] <- (f(call_strikes[2]) - f(call_strikes[1])) / (call_strikes[2] - call_strikes[1])\n  n_tmp <- length(call_strikes)\n  for (i in 2:(n_tmp - 1)) {\n    call_weights[i] <- (f(call_strikes[i+1]) - f(call_strikes[i])) / (call_strikes[i+1] - call_strikes[i]) - sum(call_weights[1:(i-1)])\n  }\n  k_tmp <- call_strikes[n_tmp] + (call_strikes[n_tmp] - call_strikes[n_tmp - 1])\n  call_weights[n_tmp] <- (f(k_tmp) - f(call_strikes[n_tmp])) / (k_tmp - call_strikes[n_tmp]) - sum(call_weights[1:(n_tmp-1)])\n  # for put weights\n  put_weights <- c()\n  put_weights[1] <- (f(put_strikes[2]) - f(put_strikes[1])) / (put_strikes[1] - put_strikes[2])\n  n_tmp <- length(put_strikes)\n  for (i in 2:(n_tmp - 1)) {\n    put_weights[i] <- (f(put_strikes[i+1]) - f(put_strikes[i])) / (put_strikes[i] - put_strikes[i+1]) - sum(put_weights[1:(i-1)])\n  }\n  k_tmp <- put_strikes[n_tmp] + (put_strikes[n_tmp] - put_strikes[n_tmp - 1])\n  put_weights[n_tmp] <- (f(k_tmp) - f(put_strikes[n_tmp])) / (put_strikes[n_tmp] - k_tmp) - sum(put_weights[1:(n_tmp-1)])\n  \n  # compute call and put price series\n  put_series <- apply(cbind(put_strikes, put_IVs), 1, function(x) {\n    BSPricer(S = S, K = x[1], r = r, Ttm = Ttm, vol = x[2], type = \"p\")\n  })\n  call_series <- apply(cbind(call_strikes, call_IVs), 1, function(x) {\n    BSPricer(S = S, K = x[1], r = r, Ttm = Ttm, vol = x[2], type = \"c\")\n  })\n  \n  # sum results\n  sum_cp <- sum(put_weights * put_series) + sum(call_weights * call_series)\n  \n  # price formula\n  kvar <- (2/Ttm) * (r*Ttm - (S*exp(r*Ttm)/ref_S - 1) - log(ref_S/S)) + exp(r*Ttm)*sum_cp\n  \n  # return \n  return(kvar)\n  #return(sum_cp)\n  #return(list(pweight=put_weights, pprice=put_series, cweight=call_weights, cprice=call_series))\n}\n\n# # test GS paper P21 example\n# put_strikes_tmp <- rev(seq(from=50, to=100, by=5))\n# call_strikes_tmp <- seq(from=100, to=135, by=5)\n# put_vol <- rev(seq(from=30, to=20) * 0.01)\n# call_vol <- seq(from=20, to=13) * 0.01\n# rf <- 0.05\n# S0 <- 100\n# T_m <- 90/365\n# sqrt(10000*FairVariance(S=S0, put_strikes=put_strikes_tmp, call_strikes=call_strikes_tmp, \n#                              put_IVs=put_vol, call_IVs=call_vol, Ttm=T_m, r=rf, ref_S=100))\n\n# \n# # test JPMorgan Paper P17 example\n# put_strikes_new <- rev(c(1467.51, 1614.26, 1761.01, 1907.76, 2054.51, 2201.26, 2348.01, 2494.76, 2641.51, 2788.26, 2935.02))\n# call_strikes_new <- c(2935.02, 3081.77, 3228.52, 3375.27, 3522.02, 3668.77, 3815.52, 3962.27, 4109.02, 4255.77, 4402.52)\n# put_IVs_new <- rev(c(0.276, 0.264, 0.252, 0.240, 0.227, 0.214, 0.200, 0.187, 0.173, 0.160, 0.148))\n# call_IVs_new <- c(0.148, 0.137, 0.129, 0.122, 0.119, 0.118, 0.119, 0.121, 0.125, 0.129, 0.134)\n# discount_factor <- 0.977368853\n# rf <- log(1/discount_factor)\n# T_m <- 1\n# S0 <- 2935.02 * exp(-rf*T_m)\n# sqrt(FairVariance(S=S0, put_strikes = put_strikes_new, call_strikes = call_strikes_new,\n#                              put_IVs=put_IVs_new, call_IVs = call_IVs_new, Ttm = T_m, r=rf, ref_S = 2935.02))\n\n# Theoritical Fair Variance\nTheoryFairVar.IVlinearK <- function(S, sigma0=0.3, b_slope=0.2, Ttm=1, r, ref_S, K_lower, K_upper, step=0.001) {\n  # compute the Sf price\n  Sf <- S * exp(r*Ttm)\n  # obtain the upper bound of the call strikes\n  #   if(b_slope == 0) {\n  #     upper <- 200\n  #   }\n  #   else {\n  #     upper <- floor(sigma0*Sf/b_slope + Sf)\n  #   }\n  put_bound <- c(K_lower, ref_S)\n  call_bound <- c(ref_S, K_upper)\n  # cut the put and call range\n  put_range <- seq(from=put_bound[1], to=put_bound[2], by=step)\n  call_range <- seq(from=call_bound[1], to=call_bound[2], by=step)\n  # integral\n  dk_put <- step\n  dk_call <- step\n  iv_put <- rep(sigma0, length(put_range)) - b_slope*(put_range - Sf)/Sf\n  iv_call <- rep(sigma0, length(call_range)) - b_slope*(call_range - Sf)/Sf\n  price_put <- apply(cbind(put_range, iv_put), 1, function(x) {\n    BSPricer(S = S, K = x[1], r = r, Ttm = Ttm, vol = x[2], type = \"p\")\n  })\n  price_call <- apply(cbind(call_range, iv_call), 1, function(x) {\n    BSPricer(S = S, K = x[1], r = r, Ttm = Ttm, vol = x[2], type = \"c\")\n  })\n  put_integral <- sum((1/put_range^2) * price_put * dk_put)\n  call_integral <- sum((1/call_range^2) * price_call * dk_call)\n  # fair variance \n  kvar <- (2/Ttm) * (r*Ttm - (S*exp(r*Ttm)/ref_S - 1) - log(ref_S/S) + exp(r*Ttm)*(put_integral+call_integral))\n  # return result\n  return(kvar)\n}\n# test\nsqrt(10000*TheoryFairVar.IVlinearK(S=100, sigma0=0.3, b_slope=0.2, Ttm=90/365, r=0.05, ref_S=100, K_lower=10, K_upper=200, step=0.0001))\n# # test GS paper P24 example\n# b_slope <- 0.2\n# sigma0 <- 0.3\n# r <- 0.05\n# S0 <- 100\n# T_m <- 90/365\n# Sf <- S0 * exp(r*Ttm)\n# put_strikes_tmp <- rev(seq(from=10, to=100, by=1))\n# call_strikes_tmp <- seq(from=100, to=200, by=1)\n# put_vol <- rep(sigma0, length(put_strikes_tmp)) - b_slope*(put_strikes_tmp - Sf)/Sf\n# call_vol <- rep(sigma0, length(call_strikes_tmp)) - b_slope*(call_strikes_tmp - Sf)/Sf\n# sqrt(10000*FairVariance(S=S0, put_strikes=put_strikes_tmp, call_strikes=call_strikes_tmp, \n#                              put_IVs=put_vol, call_IVs=call_vol, Ttm=T_m, r=rf, ref_S=100))\n\n# the first approx pricing model\nApprox.IVlinearK <- function(S, sigma0=0.3, b_slope=0.2, Ttm=1, r, ref_S) {\n  kvar <- sigma0^2 * (1 + 3 * Ttm * b_slope^2)\n  return(kvar)\n}\n# test\nsqrt(10000*Approx.IVlinearK(S=100, sigma0=0.3, b_slope=0.2, Ttm=1))\n\n# the second approx pricing model\nApprox.IVlinearDelta <- function(S, sigma0=0.3, b_slope=0.2, Ttm=1, r, ref_S) {\n  kvar <- sigma0^2 * (1 + (b_slope*sqrt(Ttm)/sqrt(pi)) + (1/12)*(b_slope^2/sigma0^2))\n  return(kvar)\n}\n# test\nsqrt(10000*Approx.IVlinearDelta(S=100, sigma0=0.3, b_slope=0.2, Ttm=0.25))",
    "created" : 1444880351572.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2744397964",
    "id" : "2DC62089",
    "lastKnownWriteTime" : 1444880489,
    "path" : "~/Derivatives Pricers and Delta-hedge Research/Variance Swap Pricers.R",
    "project_path" : "Variance Swap Pricers.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "type" : "r_source"
}