{
    "contents" : "## Derivatives Pricers\n## Author: Ming Tian\n## Date: 2015-05-06\n## Copyright @2015 MingTian\n\n#assign the parameters firstly\nK = 100  #strike price\nmu = 0  #mean\nsig = 0.2  #sigma/annulaized volitility\nS0 = 100  #start stock price\nr = 0  #interest rate\nq = 0  #dividends of stock\ndt = 1/252  #time step\nT_m = 1  #maturity time\ntype = \"c\"  #option type\n\n# Black-Scholes Pricer\nBSPricer <- function(S, K, r, Ttm, vol, type) {\n  d1 <- (1 / (vol * sqrt(Ttm))) * (log(S / K) + (r + vol^2/2) * Ttm)\n  d2 <- d1 - vol * sqrt(Ttm)\n  if (type == \"c\") {\n    # call price\n    CallPrice <- S * pnorm(d1) - K * exp(-r * Ttm) * pnorm(d2)\n    # return\n    return(CallPrice)\n  }\n  else if (type == \"p\") {\n    # put price\n    PutPrice <- pnorm(-d2) * K * exp(-r * Ttm) - pnorm(-d1) * S\n    # return\n    return(PutPrice)\n  }\n  else {\n    stop(\"Wrong input type!\")\n  }\n}\n# # test\n# BSPricer(100, 100, 0.05, 0.25, 0.2, \"c\")\n# library(VarSwapPrice)\n# black_scholes(100, 100, 0.05, 0.25, 0.2)\n# library(fOptions)\n# GBSOption(TypeFlag=\"c\", S=100, X=100, Time=0.25, r=0.05, b=0.05, sigma=0.2)\n\n\n# 20150913 update version\nRandom.Path.New <- function(S0_ = S0, sig_ = sig, mu_ = mu, dt_ = dt, T_m_ = T_m, n_path) {\n  # generate the random vector\n  rand_vec <- rlnorm(n=(T_m_/dt_)*n_path, meanlog = mu_ - 0.5*((sig_*sqrt(1/252))^2), sdlog = sig_*sqrt(1/252))\n  \n  # build the result\n  result <- matrix(data=rand_vec, nrow=n_path, ncol=(T_m_/dt_))\n  \n  # apply the function to transform to the price ts\n  result[, 1] <- S0_\n  result_new <- t(apply(result, 1, function(x) {\n    cumprod(x)\n  }))\n  \n  # return the result\n  result_new\n}\n# # this is the new test\n# test <- Random.Path.New(n_path = 10000)\n# hist(test[,ncol(test)], breaks=50)\n\n\n#define a payoff function for vanilla options\nVanilla.Payoff <- function(K_ = K, S_end, type = \"c\")\n{\n  if(type == \"c\")  #Call\n  {\n    payoff <- max(0, (S_end - K_))\n  }\n  else  #Put\n  {\n    payoff <- max(0, (K_ - S_end))\n  }\n  payoff\n}\n\n# 20150917 updated\nDelta.Hedge.Return.Vectorization <- function(PayoffFunc, K_ = K, S0_ = S0, sig_ = sig, sig_DH = sig, \n                                             mu_ = mu, dt_ = dt, T_m_ = T_m, n_path_ = 10000, type = \"c\")\n{\n  #Call the Random.Path function firstly\n  rand_path <- Random.Path.New(n_path = n_path_)\n  #build a return result container\n  result <- c(1:n_path_)\n  #decide the option type\n  if(type == \"c\")  #Call\n  {\n    # call option price\n    d1 <- (1 / (sig_ * sqrt(T_m_))) * (log(S0_ / K_) + (0 + sig_^2/2) * T_m_)\n    d2 <- d1 - sig_ * sqrt(T_m_)\n    CallPrice <- S0_ * pnorm(d1) - K_ * exp(0) * pnorm(d2)\n    pnlfunc <- function(x) {\n      # calculate option P&L\n      S_end <- x[length(x)]\n      Opt_payoff <- PayoffFunc(K_ = K_, S_end, type = type)\n      \n      # calculate delta hedge P&L\n      S_path <- ts(x)\n      S_diff <- lag(S_path) - S_path\n      t_ts <- rev(seq(from=dt_, to=T_m_, by=dt_))\n      delta_vec <- pnorm( (1 / (sig_DH * sqrt(t_ts))) * (log(S_path / K_) + (0 + sig_DH^2/2) * t_ts) )\n      delta_vec <- delta_vec[-length(delta_vec)]\n      deltapayoff_vec <- -delta_vec * S_diff\n      deltapayoff <- sum(deltapayoff_vec)\n      \n      # return\n      (Opt_payoff + deltapayoff - CallPrice)\n    }\n    \n    result <- apply(rand_path, 1, pnlfunc)\n  }\n  else  #Put\n  {\n    #do nothing for now\n  }\n  #return\n  result\n}\n# # this is new Vectorization test\n# test <- Delta.Hedge.Return.Vectorization(PayoffFunc = Vanilla.Payoff)\n# hist(test, breaks=50)\n\n# Hedge to Market or Hedge to model Comparison\n#modify the function above\nMarket.vs.Model <- function(PayoffFunc, K_ = K, S0_ = S0, sig_ = sig, sig_DH = sig, \n                            mu_ = mu, dt_ = dt, T_m_ = T_m, n_path_ = 10000, type = \"c\")\n{\n  #Call the Random.Path function firstly\n  rand_path <- Random.Path.New(n_path = n_path_, sig_ = sig_)\n  #build a return result container\n  result <- c(1:n_path_)\n  #decide the option type\n  if(type == \"c\")  #Call\n  {\n    # call option price\n    d1 <- (1 / (sig_ * sqrt(T_m_))) * (log(S0_ / K_) + (0 + sig_^2/2) * T_m_)\n    d2 <- d1 - sig_ * sqrt(T_m_)\n    CallPrice <- S0_ * pnorm(d1) - K_ * exp(0) * pnorm(d2)\n    pnlfunc <- function(x) {\n      # calculate option P&L\n      S_end <- x[length(x)]\n      Opt_payoff <- PayoffFunc(K_ = K_, S_end, type = type)\n      \n      # calculate delta hedge P&L\n      S_path <- ts(x)\n      S_diff <- lag(S_path) - S_path\n      t_ts <- rev(seq(from=dt_, to=T_m_, by=dt_))\n      delta_vec <- pnorm( (1 / (sig_DH * sqrt(t_ts))) * (log(S_path / K_) + (0 + sig_DH^2/2) * t_ts) )\n      delta_vec <- delta_vec[-length(delta_vec)]\n      deltapayoff_vec <- -delta_vec * S_diff\n      deltapayoff <- sum(deltapayoff_vec)\n      \n      # return\n      (Opt_payoff + deltapayoff - CallPrice)\n    }\n    \n    result <- apply(rand_path, 1, pnlfunc)\n  }\n  else  #Put\n  {\n    #do nothing for now\n  }\n  #result\n  PnL <- result\n  lastp <- rand_path[,ncol(rand_path)]\n  func_vol <- function(vec)\n  {\n    vec <- ts(vec)\n    vec_l <- lag(vec)\n    vol <- sd(log(vec_l/vec))\n    return(vol*sqrt(252))\n  }\n  vol <- apply(rand_path, 1, func_vol)\n  result <- cbind(PnL, vol, lastp)\n  return(result)\n}\n\n#build the four models\nModel1 <- Market.vs.Model(PayoffFunc = Vanilla.Payoff, sig_ = 0.1, sig_DH = 0.1)\nModel2 <- Market.vs.Model(PayoffFunc = Vanilla.Payoff, sig_ = 0.1, sig_DH = 0.2)\nModel3 <- Market.vs.Model(PayoffFunc = Vanilla.Payoff, sig_ = 0.2, sig_DH = 0.1)\nModel4 <- Market.vs.Model(PayoffFunc = Vanilla.Payoff, sig_ = 0.2, sig_DH = 0.2)\n#12 figures arranged in 4 rows and 3 columns\npar(mar=c(1,1,1,1))\npar(mfrow=c(4,4))\nplot(c(0, 1), c(0, 1), ann = F, bty = 'n', type = 'n', xaxt = 'n', yaxt = 'n')\ntext(x=0.5,y=0.5, labels = \"Simulated at 10%,\\n\n     hedge at 10%\", cex=1.2)\nhist(Model1[,1], breaks=60 ,main = \"\")\nplot(x=Model1[,3], y=Model1[,1], col = \"blue\", abline(h=0), cex=0.5)\nplot(x=Model1[,2], y=Model1[,1], col = \"blue\", abline(lm(Model1[,1]~Model1[,2])), cex=0.5)\nplot(c(0, 1), c(0, 1), ann = F, bty = 'n', type = 'n', xaxt = 'n', yaxt = 'n')\ntext(x=0.5,y=0.5, labels = \"Simulated at 10%,\\n\n     hedge at 20%\", cex=1.2)\nhist(Model2[,1], breaks=60 , main = \"\")\nplot(x=Model2[,3], y=Model2[,1], col = \"blue\", abline(h=0), cex=0.5)\nplot(x=Model2[,2], y=Model2[,1], col = \"blue\", abline(lm(Model2[,1]~Model2[,2])), cex=0.5)\nplot(c(0, 1), c(0, 1), ann = F, bty = 'n', type = 'n', xaxt = 'n', yaxt = 'n')\ntext(x=0.5,y=0.5, labels = \"Simulated at 20%,\\n\n     hedge at 10%\", cex=1.2)\nhist(Model3[,1], breaks=60 , main = \"\")\nplot(x=Model3[,3], y=Model3[,1], col = \"blue\", abline(h=0), cex=0.5)\nplot(x=Model3[,2], y=Model3[,1], col = \"blue\", abline(lm(Model3[,1]~Model3[,2])), cex=0.5)\nplot(c(0, 1), c(0, 1), ann = F, bty = 'n', type = 'n', xaxt = 'n', yaxt = 'n')\ntext(x=0.5,y=0.5, labels = \"Simulated at 20%,\\n\n     hedge at 20%\", cex=1.2)\nhist(Model4[,1], breaks=60 , main = \"\")\nplot(x=Model4[,3], y=Model4[,1], col = \"blue\", abline(h=0), cex=0.5)\nplot(x=Model4[,2], y=Model4[,1], col = \"blue\", abline(lm(Model4[,1]~Model4[,2])), cex=0.5)\n\n\n# A new question about delta hedge as bellow:\n\"\nShould we hedge to model if OOTM and market if ITM? And average if ATM/NTM?\n\nOr maybe market if it is far OOTM or far ITM and model if NTM (near the money)?\n\nMake reasonable assumptions and answer this question.\n\n(At a minimum make the three graphs as before, for whatever you scenario is.)\n\"\n\nMarket.vs.Model1 <- function(PayoffFunc, K_ = K, S0_ = S0, sig_ = sig, sig_DH = sig, \n                             mu_ = mu, dt_ = dt, T_m_ = T_m, n_path_ = 10000, type = \"c\", level = 20)\n{\n  #Call the Random.Path function firstly\n  rand_path <- Random.Path.New(n_path = n_path_, sig_ = sig_)\n  #build a return result container\n  result <- c(1:n_path_)\n  #decide the option type\n  if(type == \"c\")  #Call\n  {\n    # call option price\n    d1 <- (1 / (sig_ * sqrt(T_m_))) * (log(S0_ / K_) + (0 + sig_^2/2) * T_m_)\n    d2 <- d1 - sig_ * sqrt(T_m_)\n    CallPrice <- S0_ * pnorm(d1) - K_ * exp(0) * pnorm(d2)\n    \n    # modify the function for dynamic hedgeing\n    pnlfunc <- function(x) {\n      # calculate option payoff\n      S_end <- x[length(x)]\n      Opt_payoff <- PayoffFunc(K_ = K_, S_end, type = type)\n      \n      # generate a new sigma vector\n      sig_vec <- rep(0, n=length(x))\n      sig_vec[x > (K_ + level) | x < (K_ - level)] <- sig_DH\n      sig_vec[x >= (K_ - level) & x <= (K_ + level)] <- sig_\n      #sig_vec[x == K_] <- mean(c(sig_, sig_DH))\n      \n      # calculate delta hedge P&L\n      S_path <- ts(x)\n      S_diff <- lag(S_path) - S_path\n      t_ts <- rev(seq(from=dt_, to=T_m_, by=dt_))\n      delta_vec <- pnorm( (1 / (sig_vec * sqrt(t_ts))) * (log(S_path / K_) + (0 + sig_vec^2/2) * t_ts) )\n      delta_vec <- delta_vec[-length(delta_vec)]\n      deltapayoff_vec <- -delta_vec * S_diff\n      deltapayoff <- sum(deltapayoff_vec)\n      \n      # return\n      (Opt_payoff + deltapayoff - CallPrice)\n    }\n    \n    result <- apply(rand_path, 1, pnlfunc)\n  }\n  else  #Put\n  {\n    #do nothing for now\n  }\n  #result\n  PnL <- result\n  lastp <- rand_path[,ncol(rand_path)]\n  func_vol <- function(vec)\n  {\n    vec <- ts(vec)\n    vec_l <- lag(vec)\n    vol <- sd(log(vec_l/vec))\n    return(vol*sqrt(252))\n  }\n  vol <- apply(rand_path, 1, func_vol)\n  result <- cbind(PnL, vol, lastp)\n  return(result)\n}\n\n# # test function\n# Modeltest <- Market.vs.Model1(PayoffFunc = Vanilla.Payoff, sig_ = 0.1, sig_DH = 0.1)\n# hist(Modeltest[,1], breaks=60 ,main = \"\")\n# plot(x=Modeltest[,3], y=Modeltest[,1], col = \"blue\", abline(h=0), cex=0.5)\n# plot(x=Modeltest[,2], y=Modeltest[,1], col = \"blue\", abline(lm(Modeltest[,1]~Modeltest[,2])), cex=0.5)\n\n#build the four models\nModel1 <- Market.vs.Model1(PayoffFunc = Vanilla.Payoff, sig_ = 0.1, sig_DH = 0.1, level = 10)\nModel2 <- Market.vs.Model1(PayoffFunc = Vanilla.Payoff, sig_ = 0.1, sig_DH = 0.2, level = 10)\nModel3 <- Market.vs.Model1(PayoffFunc = Vanilla.Payoff, sig_ = 0.2, sig_DH = 0.1, level = 10)\nModel4 <- Market.vs.Model1(PayoffFunc = Vanilla.Payoff, sig_ = 0.2, sig_DH = 0.2, level = 10)\n#12 figures arranged in 4 rows and 3 columns\npar(mar=c(1,1,1,1))\npar(mfrow=c(4,4))\nplot(c(0, 1), c(0, 1), ann = F, bty = 'n', type = 'n', xaxt = 'n', yaxt = 'n')\ntext(x=0.5,y=0.5, labels = \"Market at 10%,\\n\n     Model at 10%\", cex=1.2)\nhist(Model1[,1], breaks=60 ,main = \"\")\nplot(x=Model1[,3], y=Model1[,1], col = \"blue\", abline(h=0), cex=0.5)\nplot(x=Model1[,2], y=Model1[,1], col = \"blue\", abline(lm(Model1[,1]~Model1[,2])), cex=0.5)\nplot(c(0, 1), c(0, 1), ann = F, bty = 'n', type = 'n', xaxt = 'n', yaxt = 'n')\ntext(x=0.5,y=0.5, labels = \"Market at 10%,\\n\n     Model at 20%\", cex=1.2)\nhist(Model2[,1], breaks=60 , main = \"\")\nplot(x=Model2[,3], y=Model2[,1], col = \"blue\", abline(h=0), cex=0.5)\nplot(x=Model2[,2], y=Model2[,1], col = \"blue\", abline(lm(Model2[,1]~Model2[,2])), cex=0.5)\nplot(c(0, 1), c(0, 1), ann = F, bty = 'n', type = 'n', xaxt = 'n', yaxt = 'n')\ntext(x=0.5,y=0.5, labels = \"Market at 20%,\\n\n     Model at 10%\", cex=1.2)\nhist(Model3[,1], breaks=60 , main = \"\")\nplot(x=Model3[,3], y=Model3[,1], col = \"blue\", abline(h=0), cex=0.5)\nplot(x=Model3[,2], y=Model3[,1], col = \"blue\", abline(lm(Model3[,1]~Model3[,2])), cex=0.5)\nplot(c(0, 1), c(0, 1), ann = F, bty = 'n', type = 'n', xaxt = 'n', yaxt = 'n')\ntext(x=0.5,y=0.5, labels = \"Market at 20%,\\n\n     Model at 20%\", cex=1.2)\nhist(Model4[,1], breaks=60 , main = \"\")\nplot(x=Model4[,3], y=Model4[,1], col = \"blue\", abline(h=0), cex=0.5)\nplot(x=Model4[,2], y=Model4[,1], col = \"blue\", abline(lm(Model4[,1]~Model4[,2])), cex=0.5)\n\n# Why it is impossible to arbitrage from volatility skew\n\"figure out why selling 70% puts at 30 vol, buying 130% calls at 10 vol, \nand hedging both to 20 vol, won't necessarily make 20 vol points of profit\"\n\n# \"best trade\" function - the false one\nLongCallSellPutStart <- function(K_call = 130, K_put = 70, S0_ = 100, sig_sim = 0.2, sig_call = 0.1, sig_put = 0.3, sig_DH = 0.2,\n                                 mu_ = mu, dt_ = dt, T_m_ = T_m, n_path_ = 10000) {\n  #Call the Random.Path function firstly\n  rand_path <- Random.Path.New(n_path = n_path_, S0_ = S0_, sig_ = sig_sim, mu_ = mu_, dt_ = dt_, T_m_ = T_m_)\n  \n  # long call part\n  # call option price\n  d1 <- (1 / (sig_call * sqrt(T_m_))) * (log(S0_ / K_call) + (0 + sig_call^2/2) * T_m_)\n  d2 <- d1 - sig_call * sqrt(T_m_)\n  CallPrice <- S0_ * pnorm(d1) - K_call * exp(0) * pnorm(d2)\n  \n  # delta hedge function\n  pnlfunc <- function(x) {\n    # calculate option P&L\n    S_end <- x[length(x)]\n    Opt_payoff <- Vanilla.Payoff(K_ = K_call, S_end, type = \"c\")\n    \n    # calculate delta hedge P&L\n    S_path <- ts(x)\n    S_diff <- lag(S_path) - S_path\n    t_ts <- rev(seq(from=dt_, to=T_m_, by=dt_))\n    delta_vec <- pnorm( (1 / (sig_DH * sqrt(t_ts))) * (log(S_path / K_call) + (0 + sig_DH^2/2) * t_ts) )\n    delta_vec <- delta_vec[-length(delta_vec)]\n    deltapayoff_vec <- -delta_vec * S_diff\n    deltapayoff <- sum(deltapayoff_vec)\n    \n    # return\n    (Opt_payoff + deltapayoff - CallPrice)\n  }\n  \n  cresult <- apply(rand_path, 1, pnlfunc)\n  # long call part end\n  \n  # sell put part\n  # put option price\n  d1 <- (1 / (sig_put * sqrt(T_m_))) * (log(S0_ / K_put) + (0 + sig_put^2/2) * T_m_)\n  d2 <- d1 - sig_put * sqrt(T_m_)\n  PutPrice <- K_put * exp(0) * pnorm(-d2) - S0_ * pnorm(-d1)\n  \n  # delta hedge function\n  pnlfunc <- function(x) {\n    # calculate option P&L\n    S_end <- x[length(x)]\n    Opt_payoff <- Vanilla.Payoff(K_ = K_put, S_end, type = \"p\")\n    \n    # calculate delta hedge P&L\n    S_path <- ts(x)\n    S_diff <- lag(S_path) - S_path\n    t_ts <- rev(seq(from=dt_, to=T_m_, by=dt_))\n    delta_vec <- pnorm( (1 / (sig_DH * sqrt(t_ts))) * (log(S_path / K_put) + (0 + sig_DH^2/2) * t_ts) ) - 1\n    delta_vec <- delta_vec[-length(delta_vec)]\n    deltapayoff_vec <- delta_vec * S_diff\n    deltapayoff <- sum(deltapayoff_vec)\n    \n    # return\n    (-Opt_payoff + deltapayoff + PutPrice)\n  }\n  \n  presult <- apply(rand_path, 1, pnlfunc)\n  # sell put part end\n  \n  # result\n  result <- cresult + presult\n  \n  # return \n  return(result)\n}\n# showing result\nlcsp <- LongCallSellPutStart(mu_ = 0, dt_ = 1/252, T_m_ = 1, n_path_ = 10000)\nhist(lcsp, breaks=50)\n\n# 20151005 update version\n# local volitility function - assume linear relationship with price S\nGetLocalVol <- function(S, sigma80 = 0.4, sigma120 = 0.05) {\n  (S - 80)*(sigma120 - sigma80) / 40 + sigma80\n}\n# generate the random path from local volitility\nRandom.Path.LV <- function(S0_ = S0, mu_ = mu, dt_ = dt, T_m_ = T_m, n_path) {\n  # generate the random vector\n  # rand_vec <- rlnorm(n=(T_m_/dt_)*n_path, meanlog = mu_ - 0.5*((sig_*sqrt(1/252))^2), sdlog = sig_*sqrt(1/252))\n  \n  # build the result\n  result <- matrix(data=0, nrow=n_path, ncol=(T_m_/dt_))\n  \n  # apply the function to transform to the price ts\n  result[, 1] <- S0_\n  result_new <- t(apply(result, 1, function(x) {\n    #cumprod(x)\n    # start from the day1 and enter for loop\n    for (i in 2:length(x)) {\n      # get the local vol\n      lv <- GetLocalVol(S=x[i-1])\n      x[i] <- x[i-1] * rlnorm(n=1, meanlog = mu_ - 0.5*(lv * sqrt(1/252))^2, sdlog = lv * sqrt(1/252))\n    }\n    x\n  }))\n  # return the result\n  result_new\n}\n\n# correct \"best trade\" function - arbitrage is impossible\nLongCallSellPutStart.Correct <- function(K_call = 130, K_put = 70, S0_ = 100, sig_sim = 0.2, sig_call = 0.1, sig_put = 0.3, sig_DH = 0.2,\n                                         mu_ = mu, dt_ = dt, T_m_ = T_m, n_path_ = 10000) {\n  #Call the Random.Path function firstly\n  rand_path <- Random.Path.LV(n_path = n_path_, S0_ = S0_, mu_ = mu_, dt_ = dt_, T_m_ = T_m_)\n  \n  # long call part\n  # call option price\n  d1 <- (1 / (sig_call * sqrt(T_m_))) * (log(S0_ / K_call) + (0 + sig_call^2/2) * T_m_)\n  d2 <- d1 - sig_call * sqrt(T_m_)\n  CallPrice <- S0_ * pnorm(d1) - K_call * exp(0) * pnorm(d2)\n  \n  # delta hedge function\n  pnlfunc <- function(x) {\n    # calculate option P&L\n    S_end <- x[length(x)]\n    Opt_payoff <- Vanilla.Payoff(K_ = K_call, S_end, type = \"c\")\n    \n    # calculate delta hedge P&L\n    S_path <- ts(x)\n    S_diff <- lag(S_path) - S_path\n    t_ts <- rev(seq(from=dt_, to=T_m_, by=dt_))\n    delta_vec <- pnorm( (1 / (sig_DH * sqrt(t_ts))) * (log(S_path / K_call) + (0 + sig_DH^2/2) * t_ts) )\n    delta_vec <- delta_vec[-length(delta_vec)]\n    deltapayoff_vec <- -delta_vec * S_diff\n    deltapayoff <- sum(deltapayoff_vec)\n    \n    # return\n    (Opt_payoff + deltapayoff - CallPrice)\n  }\n  \n  cresult <- apply(rand_path, 1, pnlfunc)\n  # long call part end\n  \n  # sell put part\n  # put option price\n  d1 <- (1 / (sig_put * sqrt(T_m_))) * (log(S0_ / K_put) + (0 + sig_put^2/2) * T_m_)\n  d2 <- d1 - sig_put * sqrt(T_m_)\n  PutPrice <- K_put * exp(0) * pnorm(-d2) - S0_ * pnorm(-d1)\n  \n  # delta hedge function\n  pnlfunc <- function(x) {\n    # calculate option P&L\n    S_end <- x[length(x)]\n    Opt_payoff <- Vanilla.Payoff(K_ = K_put, S_end, type = \"p\")\n    \n    # calculate delta hedge P&L\n    S_path <- ts(x)\n    S_diff <- lag(S_path) - S_path\n    t_ts <- rev(seq(from=dt_, to=T_m_, by=dt_))\n    delta_vec <- pnorm( (1 / (sig_DH * sqrt(t_ts))) * (log(S_path / K_put) + (0 + sig_DH^2/2) * t_ts) ) - 1\n    delta_vec <- delta_vec[-length(delta_vec)]\n    deltapayoff_vec <- delta_vec * S_diff\n    deltapayoff <- sum(deltapayoff_vec)\n    \n    # return\n    (-Opt_payoff + deltapayoff + PutPrice)\n  }\n  \n  presult <- apply(rand_path, 1, pnlfunc)\n  # sell put part end\n  \n  # result\n  result <- cresult + presult\n  \n  # return \n  return(result)\n}\n# showing result\nlcsp <- LongCallSellPutStart.Correct(mu_ = 0, dt_ = 1/252, T_m_ = 1, n_path_ = 10000)\nhist(lcsp, breaks=50)\nsummary(lcsp)\n\n",
    "created" : 1444879576082.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "694484919",
    "id" : "F809B695",
    "lastKnownWriteTime" : 1444880329,
    "path" : "~/Derivatives Pricers and Delta-hedge Research/Derivative Pricers and Delta-hedge.R",
    "project_path" : "Derivative Pricers and Delta-hedge.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "type" : "r_source"
}